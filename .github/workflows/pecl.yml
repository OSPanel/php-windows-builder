name: Build PHP Extension From PECL
run-name: Build PHP Extension ${{ inputs.extension-url }}, ${{ inputs.extension-ref }}
on:
  workflow_dispatch:
    inputs:
      extension-url:
        description: 'Extension URL'
        required: true
      extension-ref:
        description: 'Extension ref'
        required: true
      php-version-list:
        description: 'PHP versions to build'
        required: false
      arch-list:
        type: choice
        options: ['x64', 'x86', 'x64,x86']
        description: 'Architectures to build'
        required: false
        default: 'x64,x86'
      ts-list:
        type: choice
        options: ['nts', 'ts', 'nts,ts']
        description: 'Thread safety to build'
        required: false
        default: 'nts,ts'
      args:
        description: 'Configure arguments'
        required: false
      libs:
        description: 'Libraries'
        required: false
      run-tests:
        type: choice
        options: ['true', 'false']
        description: 'Run tests after building the extension'
        required: false
        default: 'false'
      test-runner:
        description: 'Test runner to use'
        required: false
        default: 'run-tests.php'
      test-runner-args:
        description: 'Arguments for the test runner'
        required: false
jobs:
  get-extension-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.extension-matrix.outputs.matrix }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Get the extension matrix
        id: extension-matrix
        uses: ./extension-matrix
        with:
          extension-url: ${{ inputs.extension-url }}
          extension-ref: ${{ inputs.extension-ref }}
          php-version-list: ${{ inputs.php-version-list }}
          arch-list: ${{ inputs.arch-list }}
          ts-list: ${{ inputs.ts-list }}
  create-release:
    runs-on: ubuntu-latest
    needs: get-extension-matrix
    steps:
      - name: Ensure release exists
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          extension_url="${{ inputs.extension-url }}"
          extension=$(basename "$extension_url" | tr '[:upper:]' '[:lower:]')
          
          # Replace extension names
          case "$extension" in
            "base58-php-ext") extension="base58" ;;
            "dd-trace-php") extension="ddtrace" ;;
            "msgpack-php") extension="msgpack" ;;
            "php-firebird") extension="interbase" ;;
            "php-ext-lz4") extension="lz4" ;;
            "php-memcached") extension="memcached" ;;
            "pecl-database-oci8") extension="oci8_19" ;;
            "pecl-database-pdo_oci") extension="pdo_oci" ;;
            "pecl-text-ssdeep") extension="ssdeep" ;;
          esac

          ref="${{ inputs.extension-ref }}"
          # Remove 'v' prefix from version
          ref=$(echo "$ref" | sed 's/^v//')
          release_tag="${extension}-${ref}"
        
          if ! gh release view "${release_tag}" -R ${{ github.repository }} >/dev/null 2>&1; then
            gh release create "${release_tag}" \
              -t "${extension} ${ref}" \
              -n "Release of PECL extension '${extension}' version ${ref}" \
              -R ${{ github.repository }}
          fi
  extension:
    needs: get-extension-matrix
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix: ${{fromJson(needs.get-extension-matrix.outputs.matrix)}}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Build the extension
        uses: ./extension
        with:
          extension-url: ${{ inputs.extension-url }}
          extension-ref: ${{ inputs.extension-ref }}
          php-version: ${{ matrix.php-version }}
          arch: ${{ matrix.arch }}
          ts: ${{ matrix.ts }}
          args: ${{ inputs.args }}
          libs: ${{ inputs.libs }}
          run-tests: ${{ inputs.run-tests }}
          test-runner: ${{ inputs.test-runner }}
          test-runner-args: ${{ inputs.test-runner-args }}
          build-directory: C:\b
        env:
          artifact-naming-scheme: pecl
          auto-detect-args: true
          auto-detect-libs: true
          no-debug-symbols-ddtrace: true
      - name: Upload to release immediately
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $extensionUrl = "${{ inputs.extension-url }}"
          $extensionOriginal = (Split-Path $extensionUrl -Leaf).ToLower()
          $extension = $extensionOriginal

          # Replace extension names for release
          switch ($extensionOriginal) {
            "base58-php-ext" { $extension = "base58" }
            "dd-trace-php" { $extension = "ddtrace" }
            "msgpack-php" { $extension = "msgpack" }
            "php-firebird" { $extension = "interbase" }
            "php-ext-lz4" { $extension = "lz4" }
            "php-memcached" { $extension = "memcached" }
            "pecl-database-oci8" { $extension = "oci8_19" }
            "pecl-database-pdo_oci" { $extension = "pdo_oci" }
            "pecl-text-ssdeep" { $extension = "ssdeep" }
          }

          $phpVersion = "${{ matrix.php-version }}"
          $arch = "${{ matrix.arch }}"
          $ts = "${{ matrix.ts }}"
          $ref = "${{ inputs.extension-ref }}"
          $refClean = $ref -replace '^v', ''

          $vsVersion = switch ($phpVersion) {
            { $_ -in @("7.2", "7.3", "7.4") } { "vc15" }
            { $_ -in @("8.0", "8.1", "8.2", "8.3") } { "vs16" }
            { $_ -in @("8.4", "8.5") } { "vs17" }
            default { "vs16" }
          }
          
          # Artifact name uses original extension name and ref with 'v'
          $artifactName = "php_${extensionOriginal}-${ref}-${phpVersion}-${ts}-${vsVersion}-${arch}.zip"
          $artifactNameModern = "php_${extension}-${ref}-${phpVersion}-${ts}-${vsVersion}-${arch}.zip"
          
          # Release uses new extension name and ref without 'v'
          $releaseTag = "${extension}-${refClean}"
          $releaseAssetName = "php_${extension}-${refClean}-${phpVersion}-${ts}-${vsVersion}-${arch}.zip"
          
          # Найти собранный ZIP файл с оригинальным или современным именем
          $searchPaths = @(".", "C:\b", ".\artifacts", ".\build")
          $builtFile = $null
          $finalName = $artifactName
          
          foreach ($searchPath in $searchPaths) {
            if (Test-Path $searchPath) {
              # Ищем файл с оригинальным именем
              $foundFile = Get-ChildItem -Path $searchPath -Filter $artifactName -File -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($foundFile) {
                $builtFile = $foundFile.FullName
                $finalName = $artifactName
                break
              }
              
              # Ищем файл с современным именем
              $foundFile = Get-ChildItem -Path $searchPath -Filter $artifactNameModern -File -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($foundFile) {
                $builtFile = $foundFile.FullName
                $finalName = $artifactNameModern
                break
              }
            }
          }
          
          if ($builtFile -and (Test-Path $builtFile)) {
            Write-Host "Found built file: $builtFile"
            
            # Rename the artifact file to the new naming scheme if needed
            if ($finalName -ne $releaseAssetName) {
              Copy-Item $builtFile $releaseAssetName
            } else {
              $releaseAssetName = $builtFile
            }

            # Repack the archive
            $tempDir = Join-Path $env:TEMP "repack_$(Get-Random)"
            New-Item -ItemType Directory -Path $tempDir -Force | Out-Null
            
            try {
              Write-Host "Extracting and repacking archive: $releaseAssetName"
              
              # Extract archive to temporary directory
              Expand-Archive -Path $releaseAssetName -DestinationPath $tempDir -Force
              
              # Remove original archive
              Remove-Item $releaseAssetName -Force
              
              # Create subdirectories
              $extDir = Join-Path $tempDir "ext"
              $thirdPartyDir = Join-Path $tempDir "3rd-party\$extension"
              New-Item -ItemType Directory -Path $extDir -Force | Out-Null
              New-Item -ItemType Directory -Path $thirdPartyDir -Force | Out-Null
              
              # Step 4: Move main extension DLL to ext folder (process all files recursively except bin)
              Get-ChildItem -Path $tempDir -Recurse -File | Where-Object { 
                $_.FullName -notlike "*\bin\*" -and $_.Name -eq "php_${extension}.dll" 
              } | ForEach-Object {
                $destPath = Join-Path $extDir $_.Name
                Move-Item $_.FullName $destPath -Force
                Write-Host "Moved $($_.Name) to ext folder"
              }
              
              # Step 5 & 6: Process bin folder
              $binDir = Join-Path $tempDir "bin"
              if (Test-Path $binDir) {
                # Move openssl.exe and tidy.exe to root if they exist
                foreach ($fileName in @("openssl.exe", "tidy.exe")) {
                  $filePath = Join-Path $binDir $fileName
                  if (Test-Path $filePath) {
                    $destPath = Join-Path $tempDir $fileName
                    Move-Item $filePath $destPath -Force
                    Write-Host "Moved $fileName to root"
                  }
                }
                
                # Move sasl2\plugin_sasldb.dll from bin to root as sasl2\plugin_sasldb.dll
                $saslPlugin = Join-Path $binDir "sasl2\plugin_sasldb.dll"
                if (Test-Path $saslPlugin) {
                  $sasl2Dir = Join-Path $tempDir "sasl2"
                  New-Item -ItemType Directory -Path $sasl2Dir -Force | Out-Null
                  $destPath = Join-Path $sasl2Dir "plugin_sasldb.dll"
                  if (-not (Test-Path $destPath)) {
                    New-Item -ItemType Directory -Path $sasl2Dir -Force | Out-Null
                    Move-Item $saslPlugin $destPath -Force
                    Write-Host "Moved sasl2\plugin_sasldb.dll to root"
                  }
                }
              }
              
              # Step 7: Remove ImageMagick files if extension is imagick
              if ($extension -eq "imagick") {
                $imagickPatterns = @("IM_MOD_*.dll", "CORE_RL_*.dll", "FILTER_*.dll")
                foreach ($pattern in $imagickPatterns) {
                  Get-ChildItem -Path $tempDir -Filter $pattern -Recurse | Remove-Item -Force
                  Write-Host "Removed ImageMagick files: $pattern"
                }
              }
              
              # Step 8: Move all files and folders (except *.dll files and ext folder) to 3rd-party\$extension
              Get-ChildItem -Path $tempDir | Where-Object { 
                $_.Name -ne "ext" -and $_.Name -ne "3rd-party" -and $_.Name -ne "sasl2" -and
                ($_.PSIsContainer -or $_.Extension -ne ".dll")
              } | ForEach-Object {
                $destPath = Join-Path $thirdPartyDir $_.Name
                Move-Item $_.FullName $destPath -Force
                Write-Host "Moved $($_.Name) to 3rd-party\$extension"
              }
              
              # Step 9: Remove *.lib and *.pdb files recursively, remove bin and 3rd-party\imagick\config folders
              Get-ChildItem -Path $tempDir -Include @("*.lib", "*.pdb") -Recurse | Remove-Item -Force
              Write-Host "Removed *.lib and *.pdb files"
              
              # Remove bin folder from 3rd-party\$extension if it was moved there
              $binInThirdParty = Join-Path $thirdPartyDir "bin"
              if (Test-Path $binInThirdParty) {
                Remove-Item $binInThirdParty -Recurse -Force
                Write-Host "Removed bin folder from 3rd-party\$extension"
              }
              
              # Remove 3rd-party\imagick\config if it exists
              if ($extension -eq "imagick") {
                $imagickConfigDir = Join-Path $thirdPartyDir "config"
                if (Test-Path $imagickConfigDir) {
                  Remove-Item $imagickConfigDir -Recurse -Force
                  Write-Host "Removed 3rd-party\imagick\config folder"
                }
              }
              
              # Step 10: Create new archive
              Compress-Archive -Path "$tempDir\*" -DestinationPath $releaseAssetName -Force
              
            } finally {
              # Clean up temporary directory
              if (Test-Path $tempDir) {
                Remove-Item $tempDir -Recurse -Force
              }
            }
            
            Write-Host "Uploading $releaseAssetName to release $releaseTag"
            gh release upload $releaseTag $releaseAssetName -R ${{ github.repository }} --clobber
          } else {
            Write-Host "No built ZIP file found! Searched for: $artifactName, $artifactNameModern"
            Write-Host "Current directory contents:"
            Get-ChildItem -Recurse -Filter "*.zip" -ErrorAction SilentlyContinue | ForEach-Object { Write-Host $_.FullName }
            exit 1
          }
          
  cleanup-artifacts:
    runs-on: ubuntu-latest
    if: success()
    needs: [extension]
    steps:
      - name: Cleanup artifacts after successful release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "=== Deleting artifacts after successful release ==="
          artifact_ids=$(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts --jq '.artifacts[].id' 2>/dev/null || echo "")
          if [ -n "$artifact_ids" ]; then
            for artifact_id in $artifact_ids; do
              echo "Deleting artifact $artifact_id"
              gh api -X DELETE repos/${{ github.repository }}/actions/artifacts/$artifact_id || true
            done
          fi
        
  cleanup-release:
    runs-on: ubuntu-latest
    if: failure()
    needs: [get-extension-matrix, extension]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup Release in Case of Failure
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e

          extension_url="${{ inputs.extension-url }}"
          extension=$(basename "$extension_url" | tr '[:upper:]' '[:lower:]')
          
          # Replace extension names
          case "$extension" in
            "base58-php-ext") extension="base58" ;;
            "dd-trace-php") extension="ddtrace" ;;
            "msgpack-php") extension="msgpack" ;;
            "php-firebird") extension="interbase" ;;
            "php-ext-lz4") extension="lz4" ;;
            "php-memcached") extension="memcached" ;;
            "pecl-database-oci8") extension="oci8_19" ;;
            "pecl-database-pdo_oci") extension="pdo_oci" ;;
            "pecl-text-ssdeep") extension="ssdeep" ;;
          esac
          
          ref="${{ inputs.extension-ref }}"
          # Remove 'v' prefix from version for release
          ref_clean=$(echo "$ref" | sed 's/^v//')
          release_tag="${extension}-${ref_clean}"

          echo "=== Starting cleanup for release: $release_tag ==="

          echo "=== Deleting all artifacts from this run ==="
          artifact_ids=$(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts --jq '.artifacts[].id' 2>/dev/null || echo "")
          if [ -n "$artifact_ids" ]; then
            for artifact_id in $artifact_ids; do
              echo "Deleting artifact $artifact_id"
              gh api -X DELETE repos/${{ github.repository }}/actions/artifacts/$artifact_id || true
            done
          else
            echo "No artifacts found for this run"
          fi

          echo "=== Checking if release $release_tag exists ==="
          if gh release view "$release_tag" -R ${{ github.repository }} >/dev/null 2>&1; then
            echo "Release $release_tag exists, proceeding with cleanup"
            
            echo "=== Deleting all assets from release $release_tag ==="
            assets=$(gh release view "$release_tag" -R ${{ github.repository }} --json assets --jq '.assets[].name' 2>/dev/null || echo "")
            if [ -n "$assets" ]; then
              for asset in $assets; do
                echo "Deleting asset: $asset"
                gh release delete-asset "$release_tag" "$asset" -R ${{ github.repository }} -y || true
              done
            else
              echo "No assets found in release $release_tag"
            fi

            echo "=== Deleting release $release_tag ==="
            gh release delete "$release_tag" -R ${{ github.repository }} -y || true
          else
            echo "Release $release_tag does not exist, skipping release cleanup"
          fi

          echo "=== Checking if tag $release_tag exists ==="
          if git rev-parse "refs/tags/$release_tag" >/dev/null 2>&1; then
            echo "Tag $release_tag exists, deleting it"
            git push origin ":refs/tags/$release_tag" || true
          else
            echo "Tag $release_tag does not exist, skipping tag deletion"
          fi

          echo "=== Cleanup completed successfully ==="
