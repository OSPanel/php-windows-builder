name: Build PHP Extension From PECL
run-name: Build PHP Extension ${{ inputs.extension-url }}, ${{ inputs.extension-ref }}
on:
  workflow_dispatch:
    inputs:
      extension-url:
        description: 'Extension URL'
        required: true
      extension-ref:
        description: 'Extension ref'
        required: true
      php-version-list:
        description: 'PHP versions to build'
        required: false
      arch-list:
        type: choice
        options: ['x64', 'x86', 'x64,x86']
        description: 'Architectures to build'
        required: false
        default: 'x64,x86'
      ts-list:
        type: choice
        options: ['nts', 'ts', 'nts,ts']
        description: 'Thread safety to build'
        required: false
        default: 'nts,ts'
      args:
        description: 'Configure arguments'
        required: false
      libs:
        description: 'Libraries'
        required: false
      run-tests:
        type: choice
        options: ['true', 'false']
        description: 'Run tests after building the extension'
        required: false
        default: 'false'
      test-runner:
        description: 'Test runner to use'
        required: false
        default: 'run-tests.php'
      test-runner-args:
        description: 'Arguments for the test runner'
        required: false

  repository_dispatch:
    types: [build_extension]

jobs:
  get-extension-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.extension-matrix.outputs.matrix }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Get the extension matrix
        id: extension-matrix
        uses: ./extension-matrix
        with:
          extension-url: ${{ inputs.extension-url }}
          extension-ref: ${{ inputs.extension-ref }}
          php-version-list: ${{ inputs.php-version-list }}
          arch-list: ${{ inputs.arch-list }}
          ts-list: ${{ inputs.ts-list }}

  extension:
    needs: get-extension-matrix
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.get-extension-matrix.outputs.matrix) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure release exists
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          extension_url="${{ inputs.extension-url }}"
          extension="$(basename "$extension_url" | tr '[:upper:]' '[:lower:]')"
          # Replace some repository names with extension names used in releases
          case "$extension" in
            "base58-php-ext") extension="base58" ;;
            "dd-trace-php") extension="ddtrace" ;;
            "msgpack-php") extension="msgpack" ;;
            "php-firebird") extension="interbase" ;;
            "php-ext-lz4") extension="lz4" ;;
            "php-memcached") extension="memcached" ;;
            "pecl-database-oci8") extension="oci8_19" ;;
            "pecl-database-pdo_oci") extension="pdo_oci" ;;
            "pecl-text-ssdeep") extension="ssdeep" ;;
          esac

          ref="${{ inputs.extension-ref }}"
          # Strip 'v' prefix from version for the release tag
          ref_clean="$(echo "$ref" | sed 's/^v//')"
          release_tag="${extension}-${ref_clean}"

          # Create release if it does not exist
          if ! gh release view "${release_tag}" -R ${{ github.repository }} >/dev/null 2>&1; then
            gh release create "${release_tag}" \
              -t "${extension} ${ref_clean}" \
              -n "Release of PECL extension '${extension}' version ${ref_clean}" \
              -R ${{ github.repository }}
          fi

      - name: Build the extension
        uses: ./extension
        with:
          extension-url: ${{ inputs.extension-url }}
          extension-ref: ${{ inputs.extension-ref }}
          php-version: ${{ matrix.php-version }}
          arch: ${{ matrix.arch }}
          ts: ${{ matrix.ts }}
          args: ${{ inputs.args }}
          libs: ${{ inputs.libs }}
          run-tests: ${{ inputs.run-tests }}
          test-runner: ${{ inputs.test-runner }}
          test-runner-args: ${{ inputs.test-runner-args }}
          build-directory: C:\b
        env:
          artifact-naming-scheme: pecl
          auto-detect-args: true
          auto-detect-libs: true
          no-debug-symbols-ddtrace: true

      - name: Upload to release immediately
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $ErrorActionPreference = "Stop"

          $extensionUrl = "${{ inputs.extension-url }}"
          $extensionOriginal = (Split-Path $extensionUrl -Leaf).ToLower()
          $extension = $extensionOriginal

          # Normalize extension name for release asset naming
          switch ($extensionOriginal) {
            "base58-php-ext" { $extension = "base58" }
            "dd-trace-php" { $extension = "ddtrace" }
            "msgpack-php" { $extension = "msgpack" }
            "php-firebird" { $extension = "interbase" }
            "php-ext-lz4" { $extension = "lz4" }
            "php-memcached" { $extension = "memcached" }
            "pecl-database-oci8" { $extension = "oci8_19" }
            "pecl-database-pdo_oci" { $extension = "pdo_oci" }
            "pecl-text-ssdeep" { $extension = "ssdeep" }
          }

          $phpVersion = "${{ matrix.php-version }}"
          $arch = "${{ matrix.arch }}"
          $ts = "${{ matrix.ts }}"
          $ref = "${{ inputs.extension-ref }}"
          $refClean = $ref -replace '^v', ''

          # Derive Visual Studio toolset identifier from PHP version
          $vsVersion = switch ($phpVersion) {
            { $_ -in @("7.2", "7.3", "7.4") } { "vc15" }
            { $_ -in @("8.0", "8.1", "8.2", "8.3") } { "vs16" }
            { $_ -in @("8.4", "8.5") } { "vs17" }
            default { "vs16" }
          }

          # Possible artifact file names produced by the build
          $artifactName = "php_${extensionOriginal}-${ref}-${phpVersion}-${ts}-${vsVersion}-${arch}.zip"
          $artifactNameModern = "php_${extension}-${ref}-${phpVersion}-${ts}-${vsVersion}-${arch}.zip"

          # Final asset name in the release
          $releaseTag = "${extension}-${refClean}"
          $releaseAssetName = "php_${extension}-${refClean}-${phpVersion}-${ts}-${vsVersion}-${arch}.zip"

          # Search for the built file in common locations
          $searchPaths = @(".", "C:\b", ".\artifacts", ".\build")
          $builtFile = $null
          $finalName = $artifactName

          foreach ($searchPath in $searchPaths) {
            if (Test-Path $searchPath) {
              # Try legacy artifact name
              $foundFile = Get-ChildItem -Path $searchPath -Filter $artifactName -File -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($foundFile) { $builtFile = $foundFile.FullName; $finalName = $artifactName; break }
              # Try modern artifact name
              $foundFile = Get-ChildItem -Path $searchPath -Filter $artifactNameModern -File -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($foundFile) { $builtFile = $foundFile.FullName; $finalName = $artifactNameModern; break }
            }
          }

          if (-not $builtFile -or -not (Test-Path $builtFile)) {
            Write-Host "No built ZIP file found! Searched for: $artifactName, $artifactNameModern"
            Write-Host "Current directory contents:"
            Get-ChildItem -Recurse -Filter "*.zip" -ErrorAction SilentlyContinue | ForEach-Object { Write-Host $_.FullName }
            exit 1
          }

          Write-Host "Found built file: $builtFile"

          # Ensure the file name matches the intended release asset name
          if ($finalName -ne $releaseAssetName) {
            Copy-Item $builtFile $releaseAssetName -Force
            $artifactPathToUpload = (Resolve-Path $releaseAssetName).Path
          } else {
            $artifactPathToUpload = $builtFile
          }

          # Repack the archive into a normalized structure
          $tempDir = Join-Path $env:TEMP "repack_$(Get-Random)"
          New-Item -ItemType Directory -Path $tempDir -Force | Out-Null

          try {
            Write-Host "Extracting and repacking archive: $artifactPathToUpload"
            Expand-Archive -Path $artifactPathToUpload -DestinationPath $tempDir -Force
            Remove-Item $artifactPathToUpload -Force

            # Create target directories
            $extDir = Join-Path $tempDir "ext"
            $thirdPartyDir = Join-Path $tempDir "3rd-party\$extension"
            New-Item -ItemType Directory -Path $extDir -Force | Out-Null
            New-Item -ItemType Directory -Path $thirdPartyDir -Force | Out-Null

            # Move main extension DLL into ext/
            $rootDll = Join-Path $tempDir "php_${extension}.dll"
            if (Test-Path $rootDll) {
              Move-Item $rootDll (Join-Path $extDir "php_${extension}.dll") -Force
            }

            # Process bin/ folder: keep only required items and remove the folder
            $binDir = Join-Path $tempDir "bin"
            if (Test-Path $binDir) {
              # Move sasl2\plugin_sasldb.dll to top-level sasl2\ if present
              $saslPlugin = Join-Path $binDir "sasl2\plugin_sasldb.dll"
              if (Test-Path $saslPlugin) {
                $sasl2Dir = Join-Path $tempDir "sasl2"
                New-Item -ItemType Directory -Path $sasl2Dir -Force | Out-Null
                if (-not (Test-Path (Join-Path $sasl2Dir "plugin_sasldb.dll"))) {
                  Move-Item $saslPlugin (Join-Path $sasl2Dir "plugin_sasldb.dll") -Force
                }
              }
              Remove-Item $binDir -Recurse -Force
            }

            # Drop *.lib and *.pdb debug/import files
            Get-ChildItem -Path $tempDir -Include @("*.lib", "*.pdb") -Recurse | Remove-Item -Force

            # Move everything except dlls/ext/3rd-party/sasl2 (and Imagick config) into 3rd-party/<ext>/
            Get-ChildItem -Path $tempDir | Where-Object {
              $_.Name -ne 'ext' -and
              $_.Name -ne '3rd-party' -and
              $_.Name -ne 'sasl2' -and
              ( $_.PSIsContainer -or ($_.Extension -notin @('.dll')) ) -and
              -not ( $extension -eq 'imagick' -and $_.PSIsContainer -and $_.Name -eq 'config' )
            } | ForEach-Object {
              Move-Item -Path $_.FullName -Destination (Join-Path $thirdPartyDir $_.Name) -Force
            }

            # Pack the normalized folder structure into the final asset
            Compress-Archive -Path "$tempDir\*" -DestinationPath $releaseAssetName -Force
          }
          finally {
            if (Test-Path $tempDir) { Remove-Item $tempDir -Recurse -Force }
          }

          Write-Host "Uploading $releaseAssetName to release $releaseTag"
          gh release upload $releaseTag $releaseAssetName -R ${{ github.repository }} --clobber

          # Targeted cleanup: delete only artifacts of this job that correspond to the uploaded asset
          Write-Host "=== Deleting only related artifacts after successful release upload ==="
          try {
            $runId = "${{ github.run_id }}"
            $repo = "${{ github.repository }}"

            # Candidate artifact names that might have been uploaded by this job
            $candidateNames = @($artifactName, $artifactNameModern, $releaseAssetName) | Where-Object { $_ -and $_.Trim() -ne "" } | Select-Object -Unique

            # Fetch artifacts of this run (id and name) and delete only matching ones
            $artifacts = gh api "repos/$repo/actions/runs/$runId/artifacts" --jq '.artifacts[] | {id: .id, name: .name}' 2>$null | ConvertFrom-Json -ErrorAction SilentlyContinue
            if ($null -eq $artifacts) {
              Write-Host "No artifacts data returned for this run"
            } else {
              foreach ($a in $artifacts) {
                if ($candidateNames -contains $a.name) {
                  Write-Host "Deleting artifact ID $($a.id) with name '$($a.name)'"
                  gh api -X DELETE "repos/$repo/actions/artifacts/$($a.id)" | Out-Null
                }
              }
            }
          } catch {
            Write-Warning "Artifacts cleanup failed: $($_.Exception.Message)"
          }

  cleanup-release:
    runs-on: ubuntu-latest
    if: failure()
    needs: [get-extension-matrix, extension]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup Release in Case of Failure
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e

          extension_url="${{ inputs.extension-url }}"
          extension=$(basename "$extension_url" | tr '[:upper:]' '[:lower:]')

          # Replace some repository names with extension names used in releases
          case "$extension" in
            "base58-php-ext") extension="base58" ;;
            "dd-trace-php") extension="ddtrace" ;;
            "msgpack-php") extension="msgpack" ;;
            "php-firebird") extension="interbase" ;;
            "php-ext-lz4") extension="lz4" ;;
            "php-memcached") extension="memcached" ;;
            "pecl-database-oci8") extension="oci8_19" ;;
            "pecl-database-pdo_oci") extension="pdo_oci" ;;
            "pecl-text-ssdeep") extension="ssdeep" ;;
          esac

          ref="${{ inputs.extension-ref }}"
          # Strip 'v' prefix from version for the release tag
          ref_clean=$(echo "$ref" | sed 's/^v//')
          release_tag="${extension}-${ref_clean}"

          echo "=== Starting cleanup for release: $release_tag ==="

          echo "=== Deleting all artifacts from this run ==="
          artifact_ids=$(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts --jq '.artifacts[].id' 2>/dev/null || echo "")
          if [ -n "$artifact_ids" ]; then
            for artifact_id in $artifact_ids; do
              echo "Deleting artifact $artifact_id"
              gh api -X DELETE repos/${{ github.repository }}/actions/artifacts/$artifact_id || true
            done
          else
            echo "No artifacts found for this run"
          fi

          echo "=== Checking if release $release_tag exists ==="
          if gh release view "$release_tag" -R ${{ github.repository }} >/dev/null 2>&1; then
            echo "Release $release_tag exists, proceeding with cleanup"

            echo "=== Deleting all assets from release $release_tag ==="
            assets=$(gh release view "$release_tag" -R ${{ github.repository }} --json assets --jq '.assets[].name' 2>/dev/null || echo "")
            if [ -n "$assets" ]; then
              for asset in $assets; do
                echo "Deleting asset: $asset"
                gh release delete-asset "$release_tag" "$asset" -R ${{ github.repository }} -y || true
              done
            else
              echo "No assets found in release $release_tag"
            fi

            echo "=== Deleting release $release_tag ==="
            gh release delete "$release_tag" -R ${{ github.repository }} -y || true
          else
            echo "Release $release_tag does not exist, skipping release cleanup"
          fi

          echo "=== Checking if tag $release_tag exists ==="
          if git rev-parse "refs/tags/$release_tag" >/dev/null 2>&1; then
            echo "Tag $release_tag exists, deleting it"
            git push origin ":refs/tags/$release_tag" || true
          else
            echo "Tag $release_tag does not exist, skipping tag deletion"
          fi

          echo "=== Cleanup completed successfully ==="