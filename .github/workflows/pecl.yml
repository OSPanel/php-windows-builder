name: Build PHP Extension From PECL
run-name: Build PHP Extension ${{ inputs.extension-url }}, ${{ inputs.extension-ref }}
on:
  workflow_dispatch:
    inputs:
      extension-url:
        description: 'Extension URL'
        required: true
      extension-ref:
        description: 'Extension ref'
        required: true
      php-version-list:
        description: 'PHP versions to build'
        required: false
      arch-list:
        type: choice
        options: ['x64', 'x86', 'x64,x86']
        description: 'Architectures to build'
        required: false
        default: 'x64,x86'
      ts-list:
        type: choice
        options: ['nts', 'ts', 'nts,ts']
        description: 'Thread safety to build'
        required: false
        default: 'nts,ts'
      args:
        description: 'Configure arguments'
        required: false
      libs:
        description: 'Libraries'
        required: false
      run-tests:
        type: choice
        options: ['true', 'false']
        description: 'Run tests after building the extension'
        required: false
        default: 'false'
      test-runner:
        description: 'Test runner to use'
        required: false
        default: 'run-tests.php'
      test-runner-args:
        description: 'Arguments for the test runner'
        required: false
jobs:
  get-extension-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.extension-matrix.outputs.matrix }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Get the extension matrix
        id: extension-matrix
        uses: ./extension-matrix
        with:
          extension-url: ${{ inputs.extension-url }}
          extension-ref: ${{ inputs.extension-ref }}
          php-version-list: ${{ inputs.php-version-list }}
          arch-list: ${{ inputs.arch-list }}
          ts-list: ${{ inputs.ts-list }}
  create-release:
    runs-on: ubuntu-latest
    needs: get-extension-matrix
    steps:
      - name: Ensure release exists
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          extension_url="${{ inputs.extension-url }}"
          extension=$(basename "$extension_url" | tr '[:upper:]' '[:lower:]')
          
          # Replace extension names
          case "$extension" in
            "base58-php-ext") extension="base58" ;;
            "dd-trace-php") extension="ddtrace" ;;
            "msgpack-php") extension="msgpack" ;;
            "php-firebird") extension="interbase" ;;
            "php-ext-lz4") extension="lz4" ;;
            "php-memcached") extension="memcached" ;;
            "pecl-database-oci8") extension="oci8_19" ;;
            "pecl-database-pdo_oci") extension="pdo_oci" ;;
            "pecl-text-ssdeep") extension="ssdeep" ;;
          esac

          ref="${{ inputs.extension-ref }}"
          # Remove 'v' prefix from version
          ref=$(echo "$ref" | sed 's/^v//')
          release_tag="${extension}-${ref}"
        
          if ! gh release view "${release_tag}" -R ${{ github.repository }} >/dev/null 2>&1; then
            gh release create "${release_tag}" \
              -t "${extension} ${ref}" \
              -n "Release of PECL extension '${extension}' version ${ref}" \
              -R ${{ github.repository }}
          fi
  extension:
    needs: get-extension-matrix
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix: ${{fromJson(needs.get-extension-matrix.outputs.matrix)}}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Build the extension
        uses: ./extension
        with:
          extension-url: ${{ inputs.extension-url }}
          extension-ref: ${{ inputs.extension-ref }}
          php-version: ${{ matrix.php-version }}
          arch: ${{ matrix.arch }}
          ts: ${{ matrix.ts }}
          args: ${{ inputs.args }}
          libs: ${{ inputs.libs }}
          run-tests: ${{ inputs.run-tests }}
          test-runner: ${{ inputs.test-runner }}
          test-runner-args: ${{ inputs.test-runner-args }}
          build-directory: C:\b
        env:
          artifact-naming-scheme: pecl
          auto-detect-args: true
          auto-detect-libs: true
          no-debug-symbols-ddtrace: true
      - name: Upload to release immediately
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $extensionUrl = "${{ inputs.extension-url }}"
          $extensionOriginal = (Split-Path $extensionUrl -Leaf).ToLower()
          $extension = $extensionOriginal

          # Replace extension names for release
          switch ($extensionOriginal) {
            "base58-php-ext" { $extension = "base58" }
            "dd-trace-php" { $extension = "ddtrace" }
            "msgpack-php" { $extension = "msgpack" }
            "php-firebird" { $extension = "interbase" }
            "php-ext-lz4" { $extension = "lz4" }
            "php-memcached" { $extension = "memcached" }
            "pecl-database-oci8" { $extension = "oci8_19" }
            "pecl-database-pdo_oci" { $extension = "pdo_oci" }
            "pecl-text-ssdeep" { $extension = "ssdeep" }
          }

          $phpVersion = "${{ matrix.php-version }}"
          $arch = "${{ matrix.arch }}"
          $ts = "${{ matrix.ts }}"
          $ref = "${{ inputs.extension-ref }}"
          $refClean = $ref -replace '^v', ''

          $vsVersion = switch ($phpVersion) {
            { $_ -in @("7.2", "7.3", "7.4") } { "vc15" }
            { $_ -in @("8.0", "8.1", "8.2", "8.3") } { "vs16" }
            { $_ -in @("8.4", "8.5") } { "vs17" }
            default { "vs16" }
          }
          
          # Artifact name uses original extension name and ref with 'v'
          $artifactName = "php_${extensionOriginal}-${ref}-${phpVersion}-${ts}-${vsVersion}-${arch}.zip"
          $artifactNameModern = "php_${extension}-${ref}-${phpVersion}-${ts}-${vsVersion}-${arch}.zip"
          
          # Release uses new extension name and ref without 'v'
          $releaseTag = "${extension}-${refClean}"
          $releaseAssetName = "php_${extension}-${refClean}-${phpVersion}-${ts}-${vsVersion}-${arch}.zip"
          
          # Найти собранный ZIP файл с оригинальным или современным именем
          $searchPaths = @(".", "C:\b", ".\artifacts", ".\build")
          $builtFile = $null
          $finalName = $artifactName
          
          foreach ($searchPath in $searchPaths) {
            if (Test-Path $searchPath) {
              # Ищем файл с оригинальным именем
              $foundFile = Get-ChildItem -Path $searchPath -Filter $artifactName -File -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($foundFile) {
                $builtFile = $foundFile.FullName
                $finalName = $artifactName
                break
              }
              
              # Ищем файл с современным именем
              $foundFile = Get-ChildItem -Path $searchPath -Filter $artifactNameModern -File -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($foundFile) {
                $builtFile = $foundFile.FullName
                $finalName = $artifactNameModern
                break
              }
            }
          }
          
          if ($builtFile -and (Test-Path $builtFile)) {
            Write-Host "Found built file: $builtFile"
            
            # Rename the artifact file to the new naming scheme if needed
            if ($finalName -ne $releaseAssetName) {
              Copy-Item $builtFile $releaseAssetName
              Write-Host "Renamed artifact to: $releaseAssetName"
            } else {
              $releaseAssetName = $builtFile
              Write-Host "Using original artifact name: $releaseAssetName"
            }
            
            # Create temporary folder for archive processing
            $tempDir = Join-Path $env:TEMP "extension_processing_$(Get-Random)"
            New-Item -ItemType Directory -Path $tempDir -Force | Out-Null
            Write-Host "Created temporary directory: $tempDir"
            
            try {
              # Extract archive to temporary folder
              Write-Host "Extracting archive to temp directory..."
              Expand-Archive -Path $releaseAssetName -DestinationPath $tempDir -Force
              Remove-Item $releaseAssetName -Force
              Write-Host "Archive extracted and original removed"
              
              # Create subfolders
              Write-Host "Creating subfolders..."
              $extDir = Join-Path $tempDir "ext"
              $extConfigDir = Join-Path $tempDir "ext-config"
              $thirdPartyDir = Join-Path $tempDir "3rd-party"
              New-Item -ItemType Directory -Path $extDir -Force | Out-Null
              New-Item -ItemType Directory -Path $extConfigDir -Force | Out-Null
              New-Item -ItemType Directory -Path $thirdPartyDir -Force | Out-Null
              Write-Host "Subfolders created: ext, ext-config, 3rd-party"
              
              # Process files recursively (except bin folder)
              Write-Host "Processing files recursively (excluding bin folder)..."
              $filesProcessed = 0
              Get-ChildItem -Path $tempDir -Recurse -File | Where-Object { $_.FullName -notmatch [regex]::Escape((Join-Path $tempDir "bin")) } | ForEach-Object {
                $file = $_
                $fileName = $file.Name
                $filesProcessed++
                
                if ($fileName -eq "php_${extension}.dll") {
                  # Move main DLL to ext
                  Move-Item $file.FullName -Destination $extDir
                  Write-Host "Moved main DLL: $fileName to ext/"
                } elseif ($fileName -notmatch "\.dll$") {
                  # Move other files (non-DLL) to 3rd-party
                  $relativePath = $file.FullName.Substring($tempDir.Length + 1)
                  $targetPath = Join-Path $thirdPartyDir $relativePath
                  $targetDir = Split-Path $targetPath -Parent
                  if (!(Test-Path $targetDir)) {
                    New-Item -ItemType Directory -Path $targetDir -Force | Out-Null
                  }
                  Move-Item $file.FullName -Destination $targetPath
                  if ($filesProcessed % 10 -eq 0) {
                    Write-Host "Processed $filesProcessed files..."
                  }
                }
              }
              Write-Host "Finished processing $filesProcessed files"
              
              # Process bin folder separately
              Write-Host "Processing bin folder..."
              $binDir = Join-Path $tempDir "bin"
              if (Test-Path $binDir) {
                Write-Host "Bin folder found, processing special files..."
                # Move openssl.exe and tidy.exe to root
                @("openssl.exe", "tidy.exe") | ForEach-Object {
                  $binFile = Join-Path $binDir $_
                  if (Test-Path $binFile) {
                    Move-Item $binFile -Destination (Join-Path $tempDir $_)
                    Write-Host "Moved $_ to root"
                  }
                }
                
                # Move sasl2\plugin_sasldb.dll
                $saslPlugin = Join-Path $binDir "sasl2\plugin_sasldb.dll"
                if (Test-Path $saslPlugin) {
                  $saslDir = Join-Path $tempDir "sasl2"
                  New-Item -ItemType Directory -Path $saslDir -Force | Out-Null
                  Move-Item $saslPlugin -Destination (Join-Path $saslDir "plugin_sasldb.dll")
                  Write-Host "Moved sasl2/plugin_sasldb.dll to root/sasl2/"
                }
              } else {
                Write-Host "No bin folder found"
              }
              
              # Remove unnecessary files and folders
              Write-Host "Removing unnecessary files and folders..."
              $libPdbFiles = Get-ChildItem -Path $tempDir -Recurse -Include "*.lib", "*.pdb"
              Write-Host "Found $($libPdbFiles.Count) .lib/.pdb files to remove"
              $libPdbFiles | Remove-Item -Force
              
              @("bin", "3rd-party\imagick\config") | ForEach-Object {
                $pathToRemove = Join-Path $tempDir $_
                if (Test-Path $pathToRemove) {
                  Remove-Item $pathToRemove -Recurse -Force
                  Write-Host "Removed folder: $_"
                }
              }
              
              # Remove imagick-specific files
              if ($extension -eq "imagick") {
                Write-Host "Extension is imagick, removing specific DLL files..."
                $imagickDlls = Get-ChildItem -Path $tempDir -Recurse -Include "IM_MOD_*.dll", "CORE_RL_*.dll", "FILTER_*.dll"
                Write-Host "Found $($imagickDlls.Count) imagick-specific DLL files to remove"
                $imagickDlls | Remove-Item -Force
              }
              
              # Download matrix files
              Write-Host "Downloading matrix files..."
              $matrixIniUrl = "https://raw.githubusercontent.com/OSPanel/OpenServerPanel/refs/heads/main/resources/matrix/matrix-ini.json"
              $matrixCommentsUrl = "https://raw.githubusercontent.com/OSPanel/OpenServerPanel/refs/heads/main/resources/matrix/matrix-ini-comments.json"
              
              $matrixIniPath = Join-Path $tempDir "matrix-ini.json"
              $matrixCommentsPath = Join-Path $tempDir "matrix-ini-comments.json"
              
              Write-Host "Downloading matrix-ini.json..."
              Invoke-WebRequest -Uri $matrixIniUrl -OutFile $matrixIniPath
              Write-Host "Downloading matrix-ini-comments.json..."
              Invoke-WebRequest -Uri $matrixCommentsUrl -OutFile $matrixCommentsPath
              Write-Host "Matrix files downloaded successfully"
              
              # Parse JSON files
              Write-Host "Parsing JSON files..."
              $matrixIni = Get-Content $matrixIniPath -Raw | ConvertFrom-Json
              $matrixComments = Get-Content $matrixCommentsPath -Raw | ConvertFrom-Json
              Write-Host "JSON files parsed, found $($matrixIni.Count) ini entries and $($matrixComments.Count) comment entries"
              
              # Create comments dictionary
              Write-Host "Creating comments dictionary..."
              $commentMap = @{}
              foreach ($comment in $matrixComments) {
                $commentMap[$comment.parameter] = $comment.comment
              }
              Write-Host "Comments dictionary created with $($commentMap.Count) entries"
              
              # Filter data for current extension
              Write-Host "Filtering data for extension: $extension"
              $extensionData = $matrixIni | Where-Object { $_.extension -eq $extension }
              Write-Host "Found $($extensionData.Count) configuration entries for extension $extension"
              
              if ($extensionData) {
                # Determine PHP version for selecting correct values
                $phpVersionKey = "${{ matrix.php-version }}"
                Write-Host "Processing configuration for PHP version: $phpVersionKey"
                
                # Create INI file
                $iniPath = Join-Path $extConfigDir "${extension}.ini"
                $lines = New-Object System.Collections.Generic.List[string]
                
                # Group by extension
                Write-Host "Building INI configuration..."
                $rows = @()
                foreach ($row in $extensionData) {
                  $param = [string]$row.parameter
                  $useFlag = [bool]$row.use
                  
                  # Find value for current PHP version
                  $valueText = ""
                  if ($row.php_versions -and $row.php_versions.PSObject.Properties[$phpVersionKey]) {
                    $valueText = [string]$row.php_versions.PSObject.Properties[$phpVersionKey].Value
                  }
                  
                  # Handle special values
                  if ($valueText -eq "(none)") { continue }
                  if ($valueText -eq "(empty)") { $valueText = "" }
                  
                  $commentText = if ($commentMap.ContainsKey($param)) { [string]$commentMap[$param] } else { "" }
                  
                  $rows += [pscustomobject]@{
                    Parameter   = $param
                    Value       = $valueText
                    Comment     = $commentText
                    IsCommented = (-not $useFlag)
                  }
                }
                
                Write-Host "Built $($rows.Count) configuration rows"
                
                if ($rows.Count -gt 0) {
                  # Position for aligning equals sign
                  $equalPosition = 38
                  $baseCommentPosition = 62
                  
                  # Section header
                  $sectionTitle = $extension
                  $separator = ";---------------------------------------"
                  
                  $lines.Add($separator)
                  $lines.Add("; $sectionTitle")
                  $lines.Add($separator)
                  $lines.Add("")
                  
                  foreach ($r in $rows) {
                    $prefix = if ($r.IsCommented) { "; " } else { "" }
                    $paramWithPrefix = "{0}{1}" -f $prefix, $r.Parameter
                    $paddedParam = $paramWithPrefix.PadRight($equalPosition)
                    $val = ($r.Value ?? "")
                    
                    $baseLine = "{0} = {1}" -f $paddedParam, $val
                    
                    if ([string]::IsNullOrEmpty($r.Comment)) {
                      $lines.Add($baseLine.TrimEnd())
                    } else {
                      if ($baseLine.Length -le $baseCommentPosition) {
                        $paddedBaseLine = $baseLine.PadRight($baseCommentPosition)
                        $line = "{0}  ; {1}" -f $paddedBaseLine, $r.Comment
                        $lines.Add($line.TrimEnd())
                      } else {
                        $line = "{0}  ; {1}" -f $baseLine, $r.Comment
                        $lines.Add($line.TrimEnd())
                      }
                    }
                  }
                  
                  $lines.Add("")
                }
                
                # Write INI file
                Set-Content -Path $iniPath -Encoding UTF8 -Value ($lines -join [Environment]::NewLine)
                Write-Host "Generated INI config: $iniPath"
              } else {
                Write-Host "No configuration data found for extension $extension"
              }
              
              # Remove temporary matrix files
              Write-Host "Cleaning up temporary matrix files..."
              Remove-Item $matrixIniPath -Force -ErrorAction SilentlyContinue
              Remove-Item $matrixCommentsPath -Force -ErrorAction SilentlyContinue
              
              # Repackage archive
              Write-Host "Repackaging archive: $releaseAssetName"
              Compress-Archive -Path "$tempDir\*" -DestinationPath $releaseAssetName -Force
              Write-Host "Archive repackaged successfully"
              
            } finally {
              # Remove temporary folder
              Write-Host "Cleaning up temporary directory..."
              if (Test-Path $tempDir) {
                Remove-Item $tempDir -Recurse -Force
                Write-Host "Temporary directory removed"
              }
            }
            
            Write-Host "Uploading $releaseAssetName to release $releaseTag"
            gh release upload $releaseTag $releaseAssetName -R ${{ github.repository }} --clobber
          } else {
            Write-Host "No built ZIP file found! Searched for: $artifactName, $artifactNameModern"
            Write-Host "Current directory contents:"
            Get-ChildItem -Recurse -Filter "*.zip" -ErrorAction SilentlyContinue | ForEach-Object { Write-Host $_.FullName }
            exit 1
          }
          
  cleanup-artifacts:
    runs-on: ubuntu-latest
    if: success()
    needs: [extension]
    steps:
      - name: Cleanup artifacts after successful release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "=== Deleting artifacts after successful release ==="
          artifact_ids=$(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts --jq '.artifacts[].id' 2>/dev/null || echo "")
          if [ -n "$artifact_ids" ]; then
            for artifact_id in $artifact_ids; do
              echo "Deleting artifact $artifact_id"
              gh api -X DELETE repos/${{ github.repository }}/actions/artifacts/$artifact_id || true
            done
          fi
        
  cleanup-release:
    runs-on: ubuntu-latest
    if: failure()
    needs: [get-extension-matrix, extension]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup Release in Case of Failure
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e

          extension_url="${{ inputs.extension-url }}"
          extension=$(basename "$extension_url" | tr '[:upper:]' '[:lower:]')
          
          # Replace extension names
          case "$extension" in
            "base58-php-ext") extension="base58" ;;
            "dd-trace-php") extension="ddtrace" ;;
            "msgpack-php") extension="msgpack" ;;
            "php-firebird") extension="interbase" ;;
            "php-ext-lz4") extension="lz4" ;;
            "php-memcached") extension="memcached" ;;
            "pecl-database-oci8") extension="oci8_19" ;;
            "pecl-database-pdo_oci") extension="pdo_oci" ;;
            "pecl-text-ssdeep") extension="ssdeep" ;;
          esac
          
          ref="${{ inputs.extension-ref }}"
          # Remove 'v' prefix from version for release
          ref_clean=$(echo "$ref" | sed 's/^v//')
          release_tag="${extension}-${ref_clean}"

          echo "=== Starting cleanup for release: $release_tag ==="

          echo "=== Deleting all artifacts from this run ==="
          artifact_ids=$(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts --jq '.artifacts[].id' 2>/dev/null || echo "")
          if [ -n "$artifact_ids" ]; then
            for artifact_id in $artifact_ids; do
              echo "Deleting artifact $artifact_id"
              gh api -X DELETE repos/${{ github.repository }}/actions/artifacts/$artifact_id || true
            done
          else
            echo "No artifacts found for this run"
          fi

          echo "=== Checking if release $release_tag exists ==="
          if gh release view "$release_tag" -R ${{ github.repository }} >/dev/null 2>&1; then
            echo "Release $release_tag exists, proceeding with cleanup"
            
            echo "=== Deleting all assets from release $release_tag ==="
            assets=$(gh release view "$release_tag" -R ${{ github.repository }} --json assets --jq '.assets[].name' 2>/dev/null || echo "")
            if [ -n "$assets" ]; then
              for asset in $assets; do
                echo "Deleting asset: $asset"
                gh release delete-asset "$release_tag" "$asset" -R ${{ github.repository }} -y || true
              done
            else
              echo "No assets found in release $release_tag"
            fi

            echo "=== Deleting release $release_tag ==="
            gh release delete "$release_tag" -R ${{ github.repository }} -y || true
          else
            echo "Release $release_tag does not exist, skipping release cleanup"
          fi

          echo "=== Checking if tag $release_tag exists ==="
          if git rev-parse "refs/tags/$release_tag" >/dev/null 2>&1; then
            echo "Tag $release_tag exists, deleting it"
            git push origin ":refs/tags/$release_tag" || true
          else
            echo "Tag $release_tag does not exist, skipping tag deletion"
          fi

          echo "=== Cleanup completed successfully ==="
